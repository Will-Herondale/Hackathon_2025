from flask import Blueprint, render_template, redirect, url_for, flash, request, jsonify
from flask_login import login_required, current_user
from flask_socketio import emit, join_room, leave_room
from app import socketio
from app.forms.messaging import MessageForm, GroupCreateForm
from app.models.db_models import Conversation, Message, ConversationParticipant, User as DBUser
from app.database import db
from sqlalchemy import or_, and_

bp = Blueprint('messaging', __name__, url_prefix='/messages')


@bp.route('/')
@login_required
def inbox():
    """Message inbox"""
    # Get user's conversations
    participant_records = ConversationParticipant.query.filter_by(
        user_id=current_user.id
    ).all()

    conversations = [p.conversation for p in participant_records]

    # Sort by last message time
    conversations.sort(key=lambda c: c.updated_at, reverse=True)

    return render_template('messaging/inbox.html', conversations=conversations)


@bp.route('/conversation/<int:conversation_id>')
@login_required
def conversation(conversation_id):
    """View specific conversation"""
    # Fetch conversation
    conversation = Conversation.query.get_or_404(conversation_id)

    # Verify user is participant
    participant = ConversationParticipant.query.filter_by(
        conversation_id=conversation_id,
        user_id=current_user.id
    ).first()

    if not participant:
        flash('You do not have access to this conversation.', 'danger')
        return redirect(url_for('messaging.inbox'))

    # Fetch messages
    messages = Message.query.filter_by(
        conversation_id=conversation_id
    ).order_by(Message.sent_at.asc()).all()

    # Get other participants
    participants = ConversationParticipant.query.filter_by(
        conversation_id=conversation_id
    ).all()

    form = MessageForm()

    return render_template('messaging/conversation.html',
                          conversation=conversation,
                          messages=messages,
                          participants=participants,
                          form=form)


@bp.route('/new/<int:user_id>')
@login_required
def new_conversation(user_id):
    """Start new conversation with user"""
    # Check if user exists
    target_user = DBUser.query.get_or_404(user_id)

    # Check if direct conversation already exists
    # Find conversations where both users are participants
    current_user_convs = ConversationParticipant.query.filter_by(
        user_id=current_user.id
    ).all()

    for conv_participant in current_user_convs:
        conv = conv_participant.conversation
        if conv.conversation_type == 'direct':
            # Check if target user is also a participant
            target_participant = ConversationParticipant.query.filter_by(
                conversation_id=conv.id,
                user_id=user_id
            ).first()
            if target_participant:
                return redirect(url_for('messaging.conversation', conversation_id=conv.id))

    # Create new direct conversation
    conversation = Conversation(
        conversation_type='direct',
        created_by=current_user.id
    )
    db.session.add(conversation)
    db.session.flush()

    # Add participants
    participant1 = ConversationParticipant(
        conversation_id=conversation.id,
        user_id=current_user.id
    )
    participant2 = ConversationParticipant(
        conversation_id=conversation.id,
        user_id=user_id
    )

    db.session.add(participant1)
    db.session.add(participant2)
    db.session.commit()

    return redirect(url_for('messaging.conversation', conversation_id=conversation.id))


@bp.route('/groups/create', methods=['GET', 'POST'])
@login_required
def create_group():
    """Create group chat"""
    form = GroupCreateForm()

    if form.validate_on_submit():
        # Create group conversation
        conversation = Conversation(
            name=form.name.data,
            description=form.description.data,
            conversation_type='group',
            group_type=form.group_type.data,
            created_by=current_user.id
        )

        db.session.add(conversation)
        db.session.flush()

        # Add creator as participant
        participant = ConversationParticipant(
            conversation_id=conversation.id,
            user_id=current_user.id
        )
        db.session.add(participant)
        db.session.commit()

        flash('Group created successfully!', 'success')
        return redirect(url_for('messaging.conversation', conversation_id=conversation.id))

    return render_template('messaging/create_group.html', form=form)


@bp.route('/groups')
@login_required
def groups():
    """Browse public groups"""
    # Get public groups
    public_groups = Conversation.query.filter_by(
        conversation_type='group',
        group_type='public'
    ).order_by(Conversation.created_at.desc()).all()

    return render_template('messaging/groups.html', groups=public_groups)


@bp.route('/groups/<int:group_id>/join', methods=['POST'])
@login_required
def join_group(group_id):
    """Join public group"""
    conversation = Conversation.query.get_or_404(group_id)

    # Verify it's a public group
    if conversation.group_type != 'public':
        return jsonify({'success': False, 'message': 'This is not a public group'}), 400

    # Check if already a member
    existing = ConversationParticipant.query.filter_by(
        conversation_id=group_id,
        user_id=current_user.id
    ).first()

    if existing:
        return jsonify({'success': False, 'message': 'Already a member of this group'}), 400

    # Add as participant
    participant = ConversationParticipant(
        conversation_id=group_id,
        user_id=current_user.id
    )
    db.session.add(participant)
    db.session.commit()

    return jsonify({'success': True})


# Socket.IO Events for Real-time Messaging

@socketio.on('join')
def on_join(data):
    """User joins conversation room"""
    room = data.get('conversation_id')
    if room:
        join_room(room)
        emit('user_joined', {'user_id': current_user.id}, room=room)


@socketio.on('leave')
def on_leave(data):
    """User leaves conversation room"""
    room = data.get('conversation_id')
    if room:
        leave_room(room)
        emit('user_left', {'user_id': current_user.id}, room=room)


@socketio.on('send_message')
def handle_message(data):
    """Handle incoming message"""
    conversation_id = data.get('conversation_id')
    content = data.get('content')

    if not conversation_id or not content:
        return

    # Save message to database
    message = Message(
        conversation_id=conversation_id,
        sender_id=current_user.id,
        content=content
    )
    db.session.add(message)

    # Update conversation timestamp
    conversation = Conversation.query.get(conversation_id)
    if conversation:
        conversation.updated_at = message.sent_at

    db.session.commit()

    # Broadcast to room
    emit('new_message', {
        'id': message.id,
        'sender_id': current_user.id,
        'sender_name': current_user.name,
        'content': content,
        'timestamp': message.sent_at.isoformat(),
        'is_sender': False
    }, room=conversation_id, skip_sid=request.sid)


@socketio.on('typing')
def handle_typing(data):
    """Handle typing indicator"""
    room = data.get('conversation_id')
    if room:
        emit('user_typing', {'user_id': current_user.id, 'name': current_user.name},
             room=room, skip_sid=request.sid)
